# Программа сортировки слиянием нескольких файлов

## Рабочий инструментарий
***
+ [x] Windows 7
+ [x] IntelliJ IDEA 2023.1.4 (Community Edition)
+ [x] Oracle OpenJDK version 19.0.2
+ [x] Apache Maven version 3.9.3, [плагин Apache Maven Assembly Plugin](https://mvnrepository.com/artifact/org.apache.maven.plugins/maven-assembly-plugin/3.6.0)

## Что внутри PetrovTestCFT
***
+ В корне папки лежат:
  > примеры входных файлов,  
  файл pom.xml с конфигурацией проекта при его создании с помощью системы сборки Maven
+ По пути `out\artifacts\PetrovTestCFT_jar` находится «сбилденный» исполняемый jar-файл `PetrovTestCFT.jar`
+ По пути `src\main\java\cft\petrov` файлы программы с разрешением .java</li>
+ По пути `src\main\resources\META-INF` лежит файл MANIFEST.MF c указанием входной точки в программу.
+ По пути `target\classes\cft\petrov` скомпилированные файлы программы с разрешением .class.</li>

## Аргументы и файлы
***
Допустимые аргументы командной строки, по порядку:

1. Режим сортировки данных входных файлов
   > "-a" или "-A" – по возрастанию (_выбор по умолчанию_)  
   > "-d" или "-D" – по убыванию

2. Тип данных, с которым работает программа
   > "-i" или "-I" – целые числа  
   > "-s" или "-S" – строки

3. Имя выходного файла

4. Имена входных файлов, **не менее одного**  

Имена файлов должны оканчиваться на `.txt`, могут содержать цифры 
и **не** могут содержать зарезервированные системой имена и ряд символов: *,:,?,",<,>,\,|,/

Подробнее об именовании файлов в Windows:  
https://learn.microsoft.com/ru-ru/windows/win32/fileio/naming-a-file?redirectedfrom=MSDN#maximum-path-length-limitation

Имена файлов в программе контролирует регулярное выражение.  
Разрешенный набор имен файлов может меняться в разных файловых системах или в разных версиях Windows.  
Поскольку я писал на Windows 7, то и требования учтены именно для этой ОС. 

Если указанного выходного файла нет в папке PetrovTestCFT, то при нормальном запуске программы с валидными аргументами 
он будет создан самой программой.  

Если программой брошено исключение <u>AccessDeniedException</u> – это означает, что у учетной записи пользователя 
нет права на запись в выходной файл.  
В этом случае необходимо изменить разрешения доступа к файлу или изменить путь к файлу на директорию, 
в которой у пользователя есть право на запись. Сам я запускаю программу с правами администратора.

Если указать в аргументах подходящее под шаблон имя входного файла, но в корне проекта такого файла не будет, 
программа сообщит об этом и «_сортировка будет выполнена без учета файла `имяФайла.txt`._»

Программа учитывает все возможные ошибки пользователя, связанные с именами аргументов, их количеством и последовательностью, 
гарантируя: или с аргументами все будет в порядке, или она преждевременно завершится при первой встреченной ошибке 
с выводом справки со всеми требованиями к переданным аргументам командной строки.  
Это позволяет пользователю быстро обнаружить и исправить все (_а их может быть много_) ошибочные аргументы.  
За проверку валидности аргументов отвечают методы класса ArgsAnalyzer.

## Особенности обработки данных входных файлов
***
В соответствии с описанием задачи «входные файлы содержат данные одного из двух видов: целые числа или строки».  
Также считается, что «_файлы предварительно отсортированы_».  
Приведенный в задании пример намекает на порядок расположения элементов в файлах по возрастанию.

Но возникает мысль: а что если файл нарушает эти условия и содержит как целочисленные, так и строковые данные, 
а строки в нем не отсортированы ?  
Я задумал осуществлять проверку строк файла на нарушение «естественного порядка сортировки» (Natural Sort Order), 
который более привычен для человека, чем машинно-ориентированный, чисто алфавитный порядок сортировки, 
и отбрасывать строки, нарушающие этот «естественный порядок».

Но первым делом каждая строка входного файла проверяется на "непустоту" и отсутствие пробелов, 
и в случае положительного результата проходит вторую проверку: на соответствие выбранному типу данных.  
Строки с положительным результатом этой проверки попадают в _список строк файла с валидным типом данных_.  
А вот уже элементы этого списка подвергаются проверке на «естественный порядок».

Согласно Natural Sort Order числа располагаются так же – по возрастанию, 
но вот строковые данные, содержащие в себе «числовую часть» – иначе, чем при алфавитном порядке.  
Эта «числовая часть» рассматривается атомарно.  
Так, при алфавитной сортировке «z**1**1» окажется перед «z**2**», потому что «1» в первой строке меньше, чем «2», 
в то время как при естественной сортировке «z**2**» идет раньше «z**11**», потому что «2» меньше, чем «11».

Таким образом, в файле `int.txt` (в корне PetrovTestCFT) с содержимым

	1
	-2
	4
	10
	9

после проверки на «естественный порядок» будут «потеряны» строки «-2» и «9».  
Остальные строки попадут в <u>общий список валидных данных всех входных файлов</u> 
(*это именно те данные, которые будут преданы сортировке слиянием, а после записаны в выходной файл*) 
при условии, что программа работает с целыми числами.

Если при этом выбран режим сортировки по убыванию, то в выходном файле окажутся:

	10
	4
	1

В случае, когда программа работает со строковыми данными, в файле `int.txt` не будет валидных данных на сортировку слиянием 
(_программа сообщит об этом пользователю_).

Рассмотрим файл `q.txt`:

	1.2
	1b
	1.5
	1c
	1a
	abc
	ac
	a
	-7
	img4
	img
	img10
	img30
	img5

Если программа работает со строковыми данными, строка № 9 с значением «-7» будет отброшена, 
т.к. может быть приведена к целочисленному типу данных (*ну вот так вот придумал*).  
Строки «1.2» и «1.5» на этом этапе не отбрасываются, т.к. не являются целыми числами и рассматриваются как строковые данные.

После проверки на «естественный порядок» будут отсеяны строки «1.5», «1a», «a», «img» и «img5».  
Оставшиеся данные будут считаться валидными и попадут в <u>общий список валидных данных всех входных файлов</u>.

В программе за «естественную сортировку» отвечает класс CustomComparator и метод checkNaturalOrdering класса InputFilesAnalyzer.

## Запуск программы
***
Запустить программу можно разными способами. Ниже приведены некоторые из них.  
ВАЖНО: если вы используете для запуска программы свои файлы, положите их в корень проекта к уже присутствующим.


### Быстрый запуск программы в IntelliJ IDEA
***
1. Вкладка `Run` –> `Edit Configurations…` –> в окошке `Run/Debug Configurations`  
   нажать `Application` –> `Main` –> в поле Program arguments ввести аргументы командной строки (см. «**Аргументы и файлы**»).
2. Нажать `Apply` и/или `OK`.
3. Вкладка `Run` –> `Run ‘Main’ (Shift + F10)`.

Пример аргументов для запуска сортировки целых чисел по убыванию:  
`-d -I out.txt int.txt int3.txt s.txt e.txt int2.txt q.txt empty.txt s2.txt`

### Запуск программы через собранный в IDEA исполняемый .jar-файл
***
1. Скопировать путь к главной папке проекта PetrovTestCFT.
2. В командной строке (`Win + R` ->  ввести `cmd` -> нажать `Enter`) или в Terminal самой IntelliJ IDEA (`Alt + F12`):  
   2.1 перейти по скопированному пути  
   (н-р, у меня это: `$ cd D:\Java\PetrovTestCFT`)  
   2.2 скопировать путь к jar-файлу:  
   `out\artifacts\PetrovTestCFT_jar\PetrovTestCFT.jar`  
   2.3 ввести команду запуска jar-файла и <аргументы программы>:  
   `$ java -jar out\artifacts\PetrovTestCFT_jar\PetrovTestCFT.jar <тип сортировки> <тип данных> <имя вых. файла> <имена вх. файлов>`

Пример запуска сортировки строковых данных по возрастанию:  
`$ java -jar out\artifacts\PetrovTestCFT_jar\PetrovTestCFT.jar -s out.txt int.txt q.txt s.txt empty.txt`

### Запуск программы посредством Maven
***
Пункты 1, 2.1 как в разделе выше.

2.2 ввести команду:  
`$ mvn clean compile assembly:single`

В target появится архив `MergeSortRun.jar`. Это исполняемый jar-файл со всеми зависимостями, нужный для запуска программы.

Иной вариант – на этом шаге можно выполнить команду:  
`$ mvn clean package`

В этом случае помимо `MergeSortRun.jar` в папке target появится еще и файл `PetrovTestCFT-1.0-SNAPSHOT.jar`  
– «обычный» JAR без встроенных зависимостей (_в контексте запуска нам он неинтересен_).

2.3. ввести команду запуска jar-файла и <аргументы программы>:  
`$ java -jar target\MergeSortRun.jar <тип сортировки> <тип данных> <имя вых. файла> <имена вх. файлов>`

Пример запуска сортировки строковых данных по убыванию:  
`$ java -jar target\MergeSortRun.jar -D -s out.txt int.txt q.txt s.txt empty.txt s2.txt`

## Послесловие
***
Спасибо за ваше время.  

Помните, даже в самом плохом коде есть что-то хорошее, если вы захотите это найти. (с) некто с Хабра
